# 消息可靠性控制功能 - 完整测试指南

## 🎯 测试目标

验证消息可靠性控制功能完全正常工作，确保：
1. ✅ 可靠性设置正确应用
2. ✅ 消息历史只包含实际发送的消息
3. ✅ 动画和统计基于真实数据
4. ✅ 用户界面反映真实情况

## 🔧 前置准备

### 1. 启动系统

**终端1 - 启动后端**:
```bash
cd /home/lijiajun/Cursor/03_Web_Interaction/distributed-pbft/backend
python main.py
```

**终端2 - 启动前端**:
```bash
cd /home/lijiajun/Cursor/03_Web_Interaction/distributed-pbft
npm run dev
```

### 2. 准备测试环境

- 打开浏览器控制台（F12）查看前端日志
- 终端1查看后端日志
- 准备至少2个浏览器窗口或标签页

## 🧪 测试场景

### 场景 1: 完全阻断单个节点（0%可靠性）

**目标**: 验证0%可靠性设置完全阻止消息发送

#### 步骤

1. **创建会话**
   - 访问 http://localhost:3000
   - 配置：
     - 节点总数: 5
     - 机器人节点: 2
     - 其他保持默认
   - 点击"创建会话"

2. **加入为节点2**
   - 扫描二维码或点击"节点2"链接
   - 等待新一轮共识开始（约10-15秒）

3. **配置可靠性**
   - 选择"拜占庭攻击"按钮
   - 点击"显示可靠性矩阵"
   - 找到"→ 节点0"
   - 将滑块拖到 **0%**
   - 观察右侧显示"0%"

4. **发送消息**
   - 等待进入"准备阶段"（Prepare Phase）
   - 点击"发送错误信息"按钮

5. **验证后端日志**

应该看到类似：
```
节点 2 更新消息可靠性配置: {0: 0, 1: 100, 3: 100, 4: 100}
❌ 节点 2 到节点 0 的准备消息被丢弃 (可靠性: 0%)
✅ 节点 2 的准备消息已发送给节点 1 (可靠性: 100%)
✅ 节点 2 的准备消息已发送给节点 3 (可靠性: 100%)
✅ 节点 2 的准备消息已发送给节点 4 (可靠性: 100%)
```

6. **验证消息历史API**

在浏览器中访问或使用curl：
```bash
curl http://localhost:8000/api/sessions/{session_id}/history?round=1
```

检查返回的 `prepare` 数组，应该：
- 只包含3条来自节点2的消息（发给节点1、3、4）
- **不包含**发给节点0的消息

#### ✅ 预期结果

- [x] 后端日志显示节点0的消息被丢弃
- [x] 其他节点的消息正常发送
- [x] 消息历史中没有发给节点0的消息
- [x] 节点0的"收到的消息"列表中没有来自节点2的消息

---

### 场景 2: 批量设置0%（完全阻断所有通信）

**目标**: 验证批量设置功能和完全阻断场景

#### 步骤

1. **继续上一个场景**（或创建新会话）

2. **批量设置0%**
   - 在可靠性矩阵中
   - 点击快速设置的 **"0%"** 按钮
   - 观察所有节点的可靠性都变为0%

3. **发送消息**
   - 点击"发送错误信息"

4. **验证后端日志**

应该看到：
```
节点 2 更新消息可靠性配置: {0: 0, 1: 0, 3: 0, 4: 0}
❌ 节点 2 到节点 0 的准备消息被丢弃 (可靠性: 0%)
❌ 节点 2 到节点 1 的准备消息被丢弃 (可靠性: 0%)
❌ 节点 2 到节点 3 的准备消息被丢弃 (可靠性: 0%)
❌ 节点 2 到节点 4 的准备消息被丢弃 (可靠性: 0%)
```

5. **验证消息历史**

```bash
curl http://localhost:8000/api/sessions/{session_id}/history?round=当前轮次
```

节点2的消息应该**完全不存在**于 `prepare` 数组中。

#### ✅ 预期结果

- [x] 所有节点都显示0%
- [x] 后端日志显示所有消息被丢弃
- [x] 消息历史中没有任何来自节点2的消息
- [x] 所有其他节点都收不到节点2的消息

---

### 场景 3: 部分可靠性（50%）

**目标**: 验证概率性消息丢弃

#### 步骤

1. **设置50%可靠性**
   - 点击快速设置的 **"50%"** 按钮

2. **多次发送消息**
   - 连续点击"发送错误信息" **10次**
   - 观察后端日志

3. **统计结果**

计算：
- 成功发送的消息数量（✅）
- 被丢弃的消息数量（❌）
- 实际丢包率

#### ✅ 预期结果

- [x] 大约50%的消息被丢弃
- [x] 大约50%的消息成功发送
- [x] 结果符合随机分布（不是恰好50%，但接近）

**示例日志**:
```
✅ 节点 2 的准备消息已发送给节点 0 (可靠性: 50%)
❌ 节点 2 到节点 1 的准备消息被丢弃 (可靠性: 50%)
✅ 节点 2 的准备消息已发送给节点 3 (可靠性: 50%)
❌ 节点 2 到节点 4 的准备消息被丢弃 (可靠性: 50%)
```

---

### 场景 4: 恢复正常通信（100%）

**目标**: 验证恢复功能

#### 步骤

1. **恢复100%可靠性**
   - 点击快速设置的 **"100%"** 按钮

2. **发送消息**
   - 点击"发送错误信息"

3. **验证后端日志**

应该看到：
```
节点 2 更新消息可靠性配置: {0: 100, 1: 100, 3: 100, 4: 100}
✅ 节点 2 的准备消息已发送给节点 0 (可靠性: 100%)
✅ 节点 2 的准备消息已发送给节点 1 (可靠性: 100%)
✅ 节点 2 的准备消息已发送给节点 3 (可靠性: 100%)
✅ 节点 2 的准备消息已发送给节点 4 (可靠性: 100%)
```

#### ✅ 预期结果

- [x] 所有消息成功发送
- [x] 后端日志全部显示✅
- [x] 消息历史包含所有消息
- [x] 所有节点都能收到消息

---

### 场景 5: 混合可靠性设置

**目标**: 验证单独调整每个节点的功能

#### 步骤

1. **设置不同的可靠性**
   - 节点0: 100%
   - 节点1: 75%
   - 节点3: 50%
   - 节点4: 0%

2. **多次发送消息（10次）**

3. **统计结果**
   - 节点0应该收到~10条消息
   - 节点1应该收到~7-8条消息
   - 节点3应该收到~5条消息
   - 节点4应该收到0条消息

#### ✅ 预期结果

- [x] 不同节点的到达率符合设置
- [x] 消息历史准确反映实际发送情况

---

### 场景 6: 验证消息历史和动画

**目标**: 确保历史数据和动画基于真实发送的消息

#### 步骤

1. **设置节点0为0%，其他为100%**

2. **完成一轮共识**
   - 发送prepare消息
   - 等待进入commit阶段
   - 发送commit消息

3. **查询消息历史**

```bash
# 获取轮次列表
curl http://localhost:8000/api/sessions/{session_id}/history

# 获取具体轮次的消息
curl http://localhost:8000/api/sessions/{session_id}/history?round=X
```

4. **验证返回数据**

检查 `prepare` 和 `commit` 数组：
- 应该包含发给节点1、3、4的消息
- **不应该包含**发给节点0的消息

#### ✅ 预期结果

- [x] API返回的消息只包含实际发送的
- [x] 消息数量准确
- [x] 如果有动画组件，只显示实际发送的消息
- [x] 统计数据准确

---

## 🔍 调试技巧

### 1. 查看前端日志

打开浏览器控制台，应该看到：
```
初始化可靠性配置: {0: 100, 1: 100, 3: 100, 4: 100}
已发送初始可靠性配置到后端
更新节点 0 的可靠性为 0%
批量设置可靠性为 0%: {0: 0, 1: 0, 3: 0, 4: 0}
```

### 2. 查看后端日志

后端日志应该清晰显示：
- 可靠性配置更新
- 每条消息的发送/丢弃状态
- 可靠性百分比

### 3. 使用浏览器网络工具

在Network标签中：
- 查看WebSocket连接
- 观察 `update_reliability` 事件
- 验证数据格式正确

### 4. 检查消息历史API

直接访问API查看原始数据：
```bash
# 获取会话信息
curl http://localhost:8000/api/sessions/{session_id}

# 获取消息历史
curl http://localhost:8000/api/sessions/{session_id}/history?round=1
```

---

## ❌ 常见问题排查

### 问题1: 设置了0%但还是收到消息

**可能原因**:
- 没有等待配置同步到后端
- 查看的是其他节点发送的消息
- 使用了旧的浏览器缓存

**解决方法**:
1. 刷新页面
2. 重启后端服务
3. 检查后端日志确认配置已更新
4. 确认发送的是当前节点的消息

### 问题2: 后端日志没有显示可靠性百分比

**可能原因**:
- 使用的是旧版本代码
- 配置没有发送到后端

**解决方法**:
1. 确认代码已更新
2. 重启后端服务
3. 检查前端控制台是否有错误

### 问题3: 消息历史包含未发送的消息

**可能原因**:
- 使用的是修复前的代码
- 查看的是错误的轮次

**解决方法**:
1. 确认代码已更新到最新版本
2. 重启后端和前端
3. 查看正确的轮次号

---

## 📊 测试记录表

| 场景 | 测试时间 | 结果 | 备注 |
|-----|---------|------|-----|
| 场景1: 单节点0% | _______ | ☐通过 ☐失败 | _______ |
| 场景2: 批量0% | _______ | ☐通过 ☐失败 | _______ |
| 场景3: 50%概率 | _______ | ☐通过 ☐失败 | _______ |
| 场景4: 恢复100% | _______ | ☐通过 ☐失败 | _______ |
| 场景5: 混合设置 | _______ | ☐通过 ☐失败 | _______ |
| 场景6: 历史验证 | _______ | ☐通过 ☐失败 | _______ |

---

## ✅ 测试通过标准

所有以下条件都满足才算测试通过：

1. ✅ 设置0%可靠性时，消息被完全阻断
2. ✅ 后端日志清晰显示消息被丢弃（❌）
3. ✅ 消息历史中不包含未发送的消息
4. ✅ 不同可靠性设置产生相应的结果
5. ✅ 快速设置按钮正常工作
6. ✅ 单独调整功能正常工作
7. ✅ 恢复100%后消息正常发送
8. ✅ API返回的数据准确
9. ✅ 前端和后端日志一致
10. ✅ 没有JavaScript错误或Python异常

---

## 🎓 学习价值

通过这些测试，你可以：

1. **理解消息可靠性**: 看到不同可靠性设置的实际效果
2. **验证PBFT容错**: 观察在消息丢失情况下共识如何进行
3. **掌握调试技巧**: 学会使用日志和API进行问题排查
4. **理解系统设计**: 了解前后端如何协同工作

---

## 📝 总结

如果所有测试场景都通过，说明：

✅ 消息可靠性控制功能完全正常  
✅ 消息记录逻辑正确  
✅ 前后端数据一致  
✅ 用户体验符合预期  

系统已经可以用于：
- 教学演示
- 算法验证
- 网络模拟
- 故障测试

祝测试顺利！🎉

---

**文档版本**: v1.0  
**最后更新**: 2025年11月11日






